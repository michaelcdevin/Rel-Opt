function [mothers, fathers] = get_parents(num_children, current_gen, gen_fitness_enum)

% Selects the parents for a generation based on fitness.
% Probabilities are randomly generated from 0 to 1, and each
% probability is matched to the nearest gen_fitness value without going
% over. Outputs are generated by mapping those gen_fitness_values to
% the original configs.

    % Create random probabilities for each child
    mother_probs = rand(num_children, 1);
    father_probs = rand(num_children, 1);
    
    % Compare the probabilities to fitness, and select the config with the
    % nearest fitness value without going over.
    fitness_repmat = repmat(gen_fitness_enum(:,2), [1 num_children]);
    mother_probs_diff = fitness_repmat - mother_probs';
    mother_probs_diff(mother_probs_diff<0) = nan;
    [~, mother_idxs] = min(mother_probs_diff);
    
    % Repeat process for second parent
    father_probs_diff = fitness_repmat - father_probs';
    father_probs_diff(father_probs_diff<0) = nan;
    [~, father_idxs] = min(father_probs_diff);
    
    % To help preserve population diversity, prevent the mother and father
    % from being the same config (unless both parents are the least fit
    % individual due to an indexing error, although this is very unlikely
    % to happen).
    incest_combos = find(mother_idxs==father_idxs);
    incest_combos = incest_combos(father_idxs(incest_combos)~=length(gen_fitness_enum));
    father_idxs(incest_combos) = father_idxs(incest_combos) + 1;
    
    % Map selected indices to the original configs
    mother_config_nums = gen_fitness_enum(mother_idxs, 1);
    mothers = current_gen(:,:,mother_config_nums);
    father_config_nums = gen_fitness_enum(father_idxs, 1);
    fathers = current_gen(:,:,father_config_nums);
end